<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/05/14/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/03/21/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>分布式系统中，有一些需要使用全局唯一ID的场景，这种时候为了防止ID冲突可以使用36位的UUID，但是UUID有一些缺点，首先他相对比较长，另外UUID一般是无序的。</p>
<p>有些时候我们希望能使用一种简单一些的ID，并且希望ID能够按照时间有序生成。</p>
<p>而twitter的snowflake解决了这种需求，最初Twitter把存储系统从MySQL迁移到Cassandra，因为Cassandra没有顺序ID生成机制，所以开发了这样一套全局唯一ID生成服务。</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><code>Snowflake</code>生成的是Long类型的ID，一个Long类型占8个字节，每个字节占8比特，也就是说一个Long类型占64个比特。 </p>
<p>Snowflake ID组成结构： <code>正数位</code>（占1比特）+ <code>时间戳</code>（占41比特）+ <code>机器ID</code>（占5比特）+ <code>数据中心</code>（占5比特）+ <code>自增值</code>（占12比特），总共64比特组成的一个Long类型。 </p>
<p>snowflake的结构如下(每部分用-分开):</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000</span><br></pre></td></tr></table></figure></div>

<ul>
<li>第一个bit位（1bit）：Java中long的最高位是符号位代表正负，正数是0，负数是1，一般生成ID都为正数，所以默认为0。</li>
<li>时间戳部分（41bit）：毫秒级的时间，不建议存当前时间戳，而是用（当前时间戳 - 固定开始时间戳）的差值，可以使产生的ID从更小的值开始；41位的时间戳可以使用69年，(1L &lt;&lt; 41) &#x2F; (1000L * 60 * 60 * 24 * 365) &#x3D; 69年</li>
<li>工作机器id（10bit）：也被叫做 <code>workId</code> ，这个可以灵活配置，机房或者机器号组合都可以。</li>
<li>序列号部分（12bit），自增值支持同一毫秒内同一个节点可以生成4096个ID</li>
</ul>
<p>一共加起来刚好64位，为一个Long型。(转换成字符串长度为18)</p>
<p>snowflake生成的ID整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和workerId作区分），并且效率较高。据说：snowflake每秒能够产生26万个ID。根据这个算法的逻辑，只需要将这个算法用Java语言实现出来，封装为一个工具方法，那么各个业务应用可以直接使用该工具方法来获取分布式ID，只需保证每个业务应用有自己的工作机器id即可，而不需要单独去搭建一个获取分布式ID的应用。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SnowflakeIdUtils &#123;</span><br><span class="line"></span><br><span class="line">    // ==============================Fields===========================================</span><br><span class="line">    /** 开始时间截 (2015-01-01) */</span><br><span class="line">    private final long twepoch = 1420041600000L;</span><br><span class="line"></span><br><span class="line">    /** 机器id所占的位数 */</span><br><span class="line">    private final long workerIdBits = 5L;</span><br><span class="line"></span><br><span class="line">    /** 数据标识id所占的位数 */</span><br><span class="line">    private final long datacenterIdBits = 5L;</span><br><span class="line"></span><br><span class="line">    /** 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */</span><br><span class="line">    private final long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits);</span><br><span class="line"></span><br><span class="line">    /** 支持的最大数据标识id，结果是31 */</span><br><span class="line">    private final long maxDatacenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits);</span><br><span class="line"></span><br><span class="line">    /** 序列在id中占的位数 */</span><br><span class="line">    private final long sequenceBits = 12L;</span><br><span class="line"></span><br><span class="line">    /** 机器ID向左移12位 */</span><br><span class="line">    private final long workerIdShift = sequenceBits;</span><br><span class="line"></span><br><span class="line">    /** 数据标识id向左移17位(12+5) */</span><br><span class="line">    private final long datacenterIdShift = sequenceBits + workerIdBits;</span><br><span class="line"></span><br><span class="line">    /** 时间截向左移22位(5+5+12) */</span><br><span class="line">    private final long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;</span><br><span class="line"></span><br><span class="line">    /** 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */</span><br><span class="line">    private final long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits);</span><br><span class="line"></span><br><span class="line">    /** 工作机器ID(0~31) */</span><br><span class="line">    private long workerId;</span><br><span class="line"></span><br><span class="line">    /** 数据中心ID(0~31) */</span><br><span class="line">    private long datacenterId;</span><br><span class="line"></span><br><span class="line">    /** 毫秒内序列(0~4095) */</span><br><span class="line">    private long sequence = 0L;</span><br><span class="line"></span><br><span class="line">    /** 上次生成ID的时间截 */</span><br><span class="line">    private long lastTimestamp = -1L;</span><br><span class="line"></span><br><span class="line">    //==============================Constructors=====================================</span><br><span class="line">    /**</span><br><span class="line">     * 构造函数</span><br><span class="line">     * @param workerId 工作ID (0~31)</span><br><span class="line">     * @param datacenterId 数据中心ID (0~31)</span><br><span class="line">     */</span><br><span class="line">    public SnowflakeIdUtils(long workerId, long datacenterId) &#123;</span><br><span class="line">        if (workerId &gt; maxWorkerId || workerId &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(String.format(&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;, maxWorkerId));</span><br><span class="line">        &#125;</span><br><span class="line">        if (datacenterId &gt; maxDatacenterId || datacenterId &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(String.format(&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;, maxDatacenterId));</span><br><span class="line">        &#125;</span><br><span class="line">        this.workerId = workerId;</span><br><span class="line">        this.datacenterId = datacenterId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ==============================Methods==========================================</span><br><span class="line">    /**</span><br><span class="line">     * 获得下一个ID (该方法是线程安全的)</span><br><span class="line">     * @return SnowflakeId</span><br><span class="line">     */</span><br><span class="line">    public synchronized long nextId() &#123;</span><br><span class="line">        long timestamp = timeGen();</span><br><span class="line"></span><br><span class="line">        //如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常</span><br><span class="line">        if (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                    String.format(&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;, lastTimestamp - timestamp));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //如果是同一时间生成的，则进行毫秒内序列</span><br><span class="line">        if (lastTimestamp == timestamp) &#123;</span><br><span class="line">            sequence = (sequence + 1) &amp; sequenceMask;</span><br><span class="line">            //毫秒内序列溢出</span><br><span class="line">            if (sequence == 0) &#123;</span><br><span class="line">                //阻塞到下一个毫秒,获得新的时间戳</span><br><span class="line">                timestamp = tilNextMillis(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //时间戳改变，毫秒内序列重置</span><br><span class="line">        else &#123;</span><br><span class="line">            sequence = 0L;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //上次生成ID的时间截</span><br><span class="line">        lastTimestamp = timestamp;</span><br><span class="line"></span><br><span class="line">        //移位并通过或运算拼到一起组成64位的ID</span><br><span class="line">        return ((timestamp - twepoch) &lt;&lt; timestampLeftShift) //</span><br><span class="line">                | (datacenterId &lt;&lt; datacenterIdShift) //</span><br><span class="line">                | (workerId &lt;&lt; workerIdShift) //</span><br><span class="line">                | sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 阻塞到下一个毫秒，直到获得新的时间戳</span><br><span class="line">     * @param lastTimestamp 上次生成ID的时间截</span><br><span class="line">     * @return 当前时间戳</span><br><span class="line">     */</span><br><span class="line">    protected long tilNextMillis(long lastTimestamp) &#123;</span><br><span class="line">        long timestamp = timeGen();</span><br><span class="line">        while (timestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">            timestamp = timeGen();</span><br><span class="line">        &#125;</span><br><span class="line">        return timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回以毫秒为单位的当前时间</span><br><span class="line">     * @return 当前时间(毫秒)</span><br><span class="line">     */</span><br><span class="line">    protected long timeGen() &#123;</span><br><span class="line">        return System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //==============================Test=============================================</span><br><span class="line">    /** 测试 */</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SnowflakeIdUtils idWorker = new SnowflakeIdUtils(0, 0);</span><br><span class="line">        for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">            long id = idWorker.nextId();</span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/03/19/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>在从Java 8开始，引入了函数式编程接口与Lambda表达式，可以让我们简化某些匿名内部类，编写更少的代码来实现功能，使用Lambda表达式可以简化匿名内部类的书写，但Lambda表达式并不能取代所有的匿名内部类，只能用来取代函数接口的简写，例如在创建一个线程时，常见的写法是这样：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">new Thread(new Runnable()&#123;// 接口名</span><br><span class="line">	@Override</span><br><span class="line">	public void run()&#123;// 方法名</span><br><span class="line">		System.out.println(&quot;Thread run()&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></div>

<p>上述代码给Tread类传递了一个匿名的Runnable对象，重载Runnable接口的run()方法来实现相应逻辑。使用lambda表达式可以简化为如下形式：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">new Thread(</span><br><span class="line">		() -&gt; System.out.println(&quot;Thread run()&quot;)// 省略接口名和方法名</span><br><span class="line">).start();</span><br></pre></td></tr></table></figure></div>

<p>还是上面说的，使用Lambda的依据是必须有相应的函数式接口，函数式接口也是Java interface的一种，即内部只有一个抽象方法的接口，需要满足：</p>
<ul>
<li>一个函数式接口只有一个抽象方法(single abstract method)；</li>
<li>Object类中的public abstract method不会被视为单一的抽象方法；</li>
<li>函数式接口可以有默认方法和静态方法；</li>
<li>函数式接口可以用@FunctionalInterface注解进行修饰。</li>
</ul>
<p>这一点跟Java是强类型语言吻合，也就是不能在代码的任何地方写Lambda表达式。实际上<em>Lambda的类型就是对应函数接口的类型</em>。Lambda表达式另一个依据是类型推断机制，在上下文信息足够的情况下，编译器可以推断出参数表的类型，而不需要显式指名。</p>
<p>自定义函数接口很容易，只需要编写一个只有一个抽象方法的接口即可。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface ConsumerInterface&lt;T&gt;&#123;</span><br><span class="line">	void accept(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面代码中的@FunctionalInterface是可选的，但加上该标注编译器会帮你检查接口是否符合函数接口规范。就像加入@Override标注会检查是否重载了函数一样。</p>
<p>有了上述接口定义，就可以写出类似如下的代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ConsumerInterface&lt;String&gt; consumer = str -&gt; System.out.println(str);</span><br></pre></td></tr></table></figure></div>

<p>Java内部也提供了一些可以直接使用的函数接口</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. Consumer&lt;T&gt;     消费型接口 </span><br><span class="line">void  accept(T t) ,提供的是无返回值的抽象方法</span><br><span class="line"></span><br><span class="line">2. Supplier &lt;T&gt;  供给型接口</span><br><span class="line">T  get()  ,  提供的是有返无参的抽象方法</span><br><span class="line"></span><br><span class="line">3. Function&lt;T,R&gt; 函数型接口    T  是参数类型,R是返回值类型</span><br><span class="line">R apply(T t)   提供的是 有参 有返的抽象方法</span><br><span class="line"></span><br><span class="line">4.Predicate &lt;T&gt; 断言型接口 </span><br><span class="line">boolean test(T t)  提供的有参有返回的方法,返回的是boolean类型的返回值</span><br></pre></td></tr></table></figure></div>



<p>这里要解释下什么是函数式编程</p>
<p>实际上，函数式编程没有一个严格的官方定义。严格上来讲，函数式编程中的“函数”，并不是指我们编程语言中的“函数”概念，而是指数学“函数”或者“表达式”（例如：y&#x3D;f(x)）。不过，在编程实现的时候，对于数学“函数”或“表达式”，我们一般习惯性地将它们设计成函数。所以，如果不深究的话，函数式编程中的“函数”也可以理解为编程语言中的“函数”。</p>
<p>每个编程范式都有自己独特的地方，这就是它们会被抽象出来作为一种范式的原因。面向对象编程最大的特点是：以类、对象作为组织代码的单元以及它的四大特性。面向过程编程最大的特点是：以函数作为组织代码的单元，数据与方法相分离。那函数式编程最独特的地方又在哪里呢？实际上，函数式编程最独特的地方在于它的编程思想。函数式编程认为程序可以用一系列数学函数或表达式的组合来表示。函数式编程是程序面向数学的更底层的抽象，将计算过程描述为表达式。不过，真的可以把任何程序都表示成一组数学表达式吗？</p>
<p>理论上讲是可以的。但是，并不是所有的程序都适合这么做。函数式编程有它自己适合的应用场景，比如科学计算、数据处理、统计分析等。在这些领域，程序往往比较容易用数学表达式来表示，比起非函数式编程，实现同样的功能，函数式编程可以用很少的代码就能搞定。但是，对于强业务相关的大型业务系统开发来说，费劲吧啦地将它抽象成数学表达式，硬要用函数式编程来实现，显然是自讨苦吃。相反，在这种应用场景下，面向对象编程更加合适，写出来的代码更加可读、可维护。</p>
<h5 id="再具体到编程实现，函数式编程跟面向过程编程一样，也是以函数作为组织代码的单元。不过，它跟面向过程编程的区别在于，它的函数是无状态的。何为无状态？简单点讲就是，函数内部涉及的变量都是局部变量，不会像面向对象编程那样，共享类成员变量，也不会像面向过程编程那样，共享全局变量。函数的执行结果只与入参有关，跟其他任何外部变量无关。同样的入参，不管怎么执行，得到的结果都是一样的。这实际上就是数学函数或数学表达式的基本要求。"><a href="#再具体到编程实现，函数式编程跟面向过程编程一样，也是以函数作为组织代码的单元。不过，它跟面向过程编程的区别在于，它的函数是无状态的。何为无状态？简单点讲就是，函数内部涉及的变量都是局部变量，不会像面向对象编程那样，共享类成员变量，也不会像面向过程编程那样，共享全局变量。函数的执行结果只与入参有关，跟其他任何外部变量无关。同样的入参，不管怎么执行，得到的结果都是一样的。这实际上就是数学函数或数学表达式的基本要求。" class="headerlink" title="再具体到编程实现，函数式编程跟面向过程编程一样，也是以函数作为组织代码的单元。不过，它跟面向过程编程的区别在于，它的函数是无状态的。何为无状态？简单点讲就是，函数内部涉及的变量都是局部变量，不会像面向对象编程那样，共享类成员变量，也不会像面向过程编程那样，共享全局变量。函数的执行结果只与入参有关，跟其他任何外部变量无关。同样的入参，不管怎么执行，得到的结果都是一样的。这实际上就是数学函数或数学表达式的基本要求。"></a>再具体到编程实现，函数式编程跟面向过程编程一样，也是以函数作为组织代码的单元。不过，它跟面向过程编程的区别在于，它的函数是无状态的。何为无状态？简单点讲就是，函数内部涉及的变量都是局部变量，不会像面向对象编程那样，共享类成员变量，也不会像面向过程编程那样，共享全局变量。函数的执行结果只与入参有关，跟其他任何外部变量无关。同样的入参，不管怎么执行，得到的结果都是一样的。这实际上就是数学函数或数学表达式的基本要求。</h5><p>类似在断言中使用的就是将函数作为参数进行传递，函数本身并无状态</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">lbsWrapper.next(this::advPredicate, advWrapper);</span><br><span class="line"></span><br><span class="line">public boolean advPredicate(Param param)&#123;</span><br><span class="line">	FeedsShowControl showControl = 	    param.getParamByName(FeedsProcessEnum.SHOW_CONTROL.getName());</span><br><span class="line">	return showControl.getShowAdv();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/05/13/%E8%87%AA%E6%9B%B4%E6%96%B0%E5%8F%82%E6%95%B0web%E6%8E%A5%E5%8F%A3%E9%A2%84%E7%83%AD%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="自更新参数web接口预热工具"><a href="#自更新参数web接口预热工具" class="headerlink" title="自更新参数web接口预热工具"></a>自更新参数web接口预热工具</h1><h3 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h3><p>日常上线流程中经常需要对接口进行预热，因为服务器每次启动后都有一定次数访问失败，如果不处理将此请求直接抛出，会降低用户体验。当服务器数量较少时，我们可以在发布机器后，待机器启动使用本地hosts更改IP，请求对应服务器接口看（1.刷新接口，2.校验返回数据）</p>
<p>然而当服务器数量较多时，这样的验证过程非常麻烦，每次需要修改完hosts，再去ping一下看看修改成功没，再去请求接口，整个集群只能测试几台机器，不能完全覆盖，主要存在两个问题：</p>
<ol>
<li>可能存在上线后有机器没起来等问题，对于数据的校验不够完善，只能看看大致返回的量，看不出具体缺失数据。</li>
<li>还有接口请求数据不够全面，都是使用很早以前的访问参数，如用户pin，经纬度，活动ID，版本号，客户端等，不能及时更新。</li>
</ol>
<p><strong>公司内部其实有很多预热工具，但都是基于固定参数的形式，类似于postman使用一套参数反复请求刷新</strong></p>
<p>预热类型分为内部预热和外部预热</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://uos.rain1024.com/image/202305132220363.png"
                      alt="image-20230513222042998"
                ></p>
<blockquote>
<p> 由此想做自动预热和报文对比，减少人为干预成本，提高覆盖率，采用外部+内部预热的方式：最大程度减少对本地代码的入侵，同时还能全面覆盖服务器，并使用最新参数刷新接口。</p>
</blockquote>
<p>下面是自更新参数预热工具的交互流程图</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://uos.rain1024.com/image/202305132150712.png"
                      alt="image.png"
                ></p>
<h2 id="服务端配置："><a href="#服务端配置：" class="headerlink" title="服务端配置："></a>服务端配置：</h2><p>这里开发了预热注解，在需要的地方加上注解，这里会拦截请求里的body+indexRequest参数，通过本地Cache缓存请求间隔次数，每隔一个小时保存一次，参数内容保存到本地缓存中，服务端不做多版本保存，每小时动态覆盖，再加上zk开关进行判断。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务预热的切面</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StartMockAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(StartMockAspect.class);</span><br><span class="line">    <span class="comment">/** */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BODY</span> <span class="operator">=</span> <span class="string">&quot;body&quot;</span>;</span><br><span class="line">    <span class="comment">/** */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">INDEX_REQUEST</span> <span class="operator">=</span> <span class="string">&quot;indexRequest&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** */</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ZkConfigManager zkConfigManager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用注解的方式定位需要拦截的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot; @annotation(com.jd.o2o.app.common.mock.DeepHttpMock)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointCut</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Cache&lt;String, Integer&gt; NUM_CACHE = CacheBuilder.newBuilder()</span><br><span class="line">            .expireAfterWrite(<span class="number">3600</span>, TimeUnit.SECONDS).build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proceedingJoinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     * InetAddress host = InetAddress.getLocalHost();</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">handle</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//配置开关</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">startFlag</span> <span class="operator">=</span> zkConfigManager.getConfig(ZkConfigPathEnum.START_PARAMETER_ASPECT_SWITCH);</span><br><span class="line">            <span class="keyword">if</span> (Boolean.FALSE.equals(startFlag)) &#123;</span><br><span class="line">                <span class="keyword">return</span> proceedingJoinPoint.proceed();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取参数</span></span><br><span class="line">            <span class="type">IndexRequest</span> <span class="variable">indexRequest</span> <span class="operator">=</span> LocaleContextHandler.getLocaleContext().getIndexRequest();</span><br><span class="line">            <span class="keyword">if</span> (proceedingJoinPoint.getSignature() <span class="keyword">instanceof</span> MethodSignature) &#123;</span><br><span class="line">                <span class="type">MethodSignature</span> <span class="variable">methodSignature</span> <span class="operator">=</span> (MethodSignature) proceedingJoinPoint.getSignature();</span><br><span class="line">                <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> methodSignature.getMethod();</span><br><span class="line">                Object[] args = proceedingJoinPoint.getArgs();</span><br><span class="line">                <span class="type">Object</span> <span class="variable">bodyRequest</span> <span class="operator">=</span> args[<span class="number">0</span>];</span><br><span class="line">                <span class="type">DeepHttpMock</span> <span class="variable">monitor</span> <span class="operator">=</span> method.getAnnotation(DeepHttpMock.class);</span><br><span class="line">                <span class="keyword">if</span> (monitor == <span class="literal">null</span> || indexRequest == <span class="literal">null</span> || bodyRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> proceedingJoinPoint.proceed();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (NUM_CACHE.get(monitor.pageSource(), () -&gt; -<span class="number">1</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">                    START_LOAD_REQUEST_MAP.put(monitor.pageSource(), ImmutableMap.of(BODY, bodyRequest, INDEX_REQUEST, indexRequest));</span><br><span class="line">                    NUM_CACHE.put(monitor.pageSource(), <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;StartMockAspect失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> proceedingJoinPoint.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>外部脚本通过特定接口访问每次缓存的一份数据</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> host</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;testStartupParameters&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">testStartupParameters</span><span class="params">(String host)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> START_LOAD_REQUEST_MAP.getOrDefault(host, Collections.emptyMap());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="python服务"><a href="#python服务" class="headerlink" title="python服务"></a>python服务</h2><p>这里采用python的原因是</p>
<ol>
<li><p>定时抓取参数的方式比较简单，适合用脚本开发，</p>
</li>
<li><p>python能够快速完成接口请求及提供web服务，开发成本较低，</p>
</li>
<li><p>可以随时更新脚本调整代码</p>
</li>
</ol>
<blockquote>
<p> python共三个模块</p>
</blockquote>
<h3 id="start-parameters模块"><a href="#start-parameters模块" class="headerlink" title="start_parameters模块"></a>start_parameters模块</h3><ol>
<li>拉取集群下所有服务器IP</li>
<li>根据host与IP配置的接口，拉取对应服务器上缓存的接口参数</li>
<li>保存所有动态URL参数内容到文件中</li>
</ol>
<h3 id="server-verify模块"><a href="#server-verify模块" class="headerlink" title="server_verify模块"></a>server_verify模块</h3><ol>
<li>使用保存的动态参数，自动&#x2F;主动-&gt;预热触发的接口</li>
<li>使用保存的动态参数，进行新旧服务器接口的报文对比</li>
</ol>
<h3 id="web模块"><a href="#web模块" class="headerlink" title="web模块"></a>web模块</h3><ol>
<li>提供主动预热服务操作页面</li>
<li>手动选择报文对比接口列表</li>
</ol>
<h2 id="下面分为三类处理"><a href="#下面分为三类处理" class="headerlink" title="下面分为三类处理"></a>下面分为三类处理</h2><h3 id="自动服务预热："><a href="#自动服务预热：" class="headerlink" title="自动服务预热："></a>自动服务预热：</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://uos.rain1024.com/image/202305132210486.png"
                      alt="img"
                ></p>
<h3 id="主动预热："><a href="#主动预热：" class="headerlink" title="主动预热："></a>主动预热：</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://uos.rain1024.com/image/202305132212775.png"
                      alt="img"
                ></p>
<h3 id="报文对比："><a href="#报文对比：" class="headerlink" title="报文对比："></a>报文对比：</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://uos.rain1024.com/image/202305132222635.png"
                      alt="image-20230513222228067" style="zoom: 47%;" 
                >

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/Users/algorain/SynologyDrive/document/markdown/%E7%9F%A5%E8%AF%86%E8%8A%B1%E5%9B%AD/assets/image-20230513224102398.png"
                      alt="image-20230513224102398"
                ></p>
<p>部分可操作界面</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://uos.rain1024.com/image/202305132213121.png"
                      alt="image.png" style="zoom:50%;" 
                >

<p>通过引用自更新参数的预热工具，相比较传统固定参数的预热工具，上线之后服务器接口性能不再出现大幅度波动，有效提高接口可用率。</p>
<p>start_before.sh</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取实例IP</span></span><br><span class="line">function_app_ip()&#123;</span><br><span class="line"><span class="keyword">if</span> [[ -n <span class="string">&quot;$def_host_ip&quot;</span> ]]; then</span><br><span class="line">echo $&#123;def_host_ip&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">echo `/sbin/ip addr sh | /<span class="built_in">bin</span>/grep -v <span class="string">&#x27;global secondary&#x27;</span> | /<span class="built_in">bin</span>/grep inet | /<span class="built_in">bin</span>/grep -v inet6 | /<span class="built_in">bin</span>/grep -v <span class="string">&#x27;127.0.0.1&#x27;</span> | /<span class="built_in">bin</span>/grep -v <span class="string">&#x27;lo:&#x27;</span> | /<span class="built_in">bin</span>/awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | /<span class="built_in">bin</span>/awk -<span class="string">F&#x27;/&#x27;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>| /usr/<span class="built_in">bin</span>/head -n <span class="number">1</span>`</span><br><span class="line">fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">echo <span class="string">&quot;开始请求预热&quot;</span> </span><br><span class="line">_app_ip=$(function_app_ip);</span><br><span class="line">echo <span class="string">&quot;操作机器IP:$_app_ip&quot;</span>  </span><br><span class="line">echo $(date +%Y-%m-%d\ %H:%M:%S)</span><br><span class="line">curl http://preheat.local/start?local=pdjhome.local\&amp;ip=$_app_ip</span><br></pre></td></tr></table></figure></div>

<p>这里是用来触发预热的任务，之后会通过python内部保存的参数URL来刷接口</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务器脚本中需要预热的访问地址</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">startHandler</span>(tornado.web.RequestHandler):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            ip = self.get_argument(<span class="string">&#x27;ip&#x27;</span>)</span><br><span class="line">            local = self.get_argument(<span class="string">&#x27;local&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(ip, local, <span class="string">&quot;发送机器预热请求&quot;</span>)</span><br><span class="line">            <span class="comment"># 启动线程异步执行</span></span><br><span class="line">            thead_one = threading.Thread(target=server_verify.web_one_start, args=(ip, local))</span><br><span class="line">            thead_one.start()</span><br><span class="line">            self.write(<span class="string">&quot;发送机器预热请求&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(e)</span><br><span class="line">            self.write(<span class="string">&quot;参数错误&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">application = tornado.web.Application([(<span class="string">r&quot;/add&quot;</span>, MainHandler),</span><br><span class="line">                                       (<span class="string">r&quot;/diff_result&quot;</span>, diffHandler),</span><br><span class="line">                                       (<span class="string">r&quot;/tool&quot;</span>, toolHandler),</span><br><span class="line">                                       (<span class="string">r&quot;/start&quot;</span>, startHandler),</span><br><span class="line">                                       (<span class="string">r&quot;/serverDiff&quot;</span>, PdjserviceHandler)],</span><br><span class="line">                                      static_path=os.path.join(os.path.dirname(__file__), <span class="string">&quot;static&quot;</span>), )</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    application.listen(<span class="number">80</span>)</span><br><span class="line">    tornado.ioloop.IOLoop.instance().start()</span><br></pre></td></tr></table></figure></div>

]]></content>
  </entry>
  <entry>
    <title>Java泛型之类型擦除</title>
    <url>/2022/03/16/Java%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4/</url>
    <content><![CDATA[<h2 id="Java泛型之类型擦除"><a href="#Java泛型之类型擦除" class="headerlink" title="Java泛型之类型擦除"></a>Java泛型之类型擦除</h2><p>在网关开发过程中，经常要应对多种任务数据抽取出公共方法来处理，这时候就会用到泛型，泛型的概念：</p>
<blockquote>
<p>泛型是Java SE 1.5的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。 Java语言引入泛型的好处是安全简单。<br>泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，以提高代码的重用率。</p>
<p>Java 泛型的参数只可以代表类，不能代表个别对象。由于 Java 泛型的类型参数之实际类型在编译时会被消除，所以无法在运行时得知其类型参数的类型。Java 编译器在编译泛型时会自动加入类型转换的编码，故运行速度不会因为使用泛型而加快。</p>
</blockquote>
<p>Java的泛型是伪泛型，这是因为Java在编译期间，所有的泛型信息都会被擦掉，正确理解泛型概念的首要前提是理解类型擦除。Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为类型擦除。</p>
<p>如在代码中定义<code>List&lt;Object&gt;</code>和<code>List&lt;String&gt;</code>等类型，在编译后都会变成<code>List</code>，JVM看到的只是<code>List</code>，而由泛型附加的类型信息对JVM是看不到的。JVM并不知道泛型的存在，因为泛型在编译阶段就已经被处理成普通的类和方法，处理机制是通过类型擦除。</p>
<p>擦除规则：</p>
<p>若泛型类型没有指定具体类型，用Object作为原始类型；<br>若有限定类型&lt; T exnteds XClass &gt;，使用XClass作为原始类型；<br>若有多个限定&lt; T exnteds XClass1 &amp; XClass2 &gt;，使用第一个边界类型XClass1作为原始类型；类型擦除引起的问题及解决方法</p>
<p>因为种种原因，Java不能实现真正的泛型，只能使用类型擦除来实现伪泛型，这样虽然不会有类型膨胀问题，但是也引起来许多新问题，所以，SUN对这些问题做出了种种限制，避免我们发生各种错误。</p>
<h4 id="1-先检查再编译以及编译的对象和引用传递问题"><a href="#1-先检查再编译以及编译的对象和引用传递问题" class="headerlink" title="1. 先检查再编译以及编译的对象和引用传递问题"></a>1. 先检查再编译以及编译的对象和引用传递问题</h4><p>既然说类型变量会在编译的时候擦除掉，那为什么我们往 ArrayList 创建的对象中添加整数会报错呢？不是说泛型变量String会在编译的时候变为Object类型吗？为什么不能存别的类型呢？既然类型擦除了，如何保证我们只能使用泛型变量限定的类型呢？</p>
<p>Java编译器是通过先检查代码中泛型的类型，然后在进行类型擦除，再进行编译。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static  void main(String[] args) &#123;  </span><br><span class="line"></span><br><span class="line">    ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();  </span><br><span class="line">    list.add(&quot;123&quot;);  </span><br><span class="line">    list.add(123);//编译错误  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在上面的程序中，使用<code>add</code>方法添加一个整型，在IDE中，直接会报错，说明这就是在编译之前的检查，因为如果是在编译之后检查，类型擦除后，原始类型为<code>Object</code>，是应该允许任意引用类型添加的。可实际上却不是这样的，这恰恰说明了关于泛型变量的使用，是会在编译之前检查的。</p>
<p>那么，这个类型检查是针对谁的呢？我们先看看参数化类型和原始类型的兼容。</p>
<p>以 ArrayList举例子，以前的写法:</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();  </span><br></pre></td></tr></table></figure></div>

<p>现在的写法:</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure></div>

<p>如果是与以前的代码兼容，各种引用传值之间，必然会出现如下的情况：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); <span class="comment">//第一种 情况</span></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(); <span class="comment">//第二种 情况</span></span><br></pre></td></tr></table></figure></div>

<p>这样是没有错误的，不过会有个编译时警告。</p>
<h4 id="2-自动类型转换"><a href="#2-自动类型转换" class="headerlink" title="2. 自动类型转换"></a>2. 自动类型转换</h4><p>因为类型擦除的问题，所以所有的泛型类型变量最后都会被替换为原始类型。</p>
<p>既然都被替换为原始类型，那么为什么我们在获取的时候，不需要进行强制类型转换呢？</p>
<p>看下<code>ArrayList.get()</code>方法：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;  </span><br><span class="line"></span><br><span class="line">    RangeCheck(index);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以看到，在<code>return</code>之前，会根据泛型变量进行强转。假设泛型类型变量为<code>Date</code>，虽然泛型信息会被擦除掉，但是会将<code>(E) elementData[index]</code>，编译为<code>(Date) elementData[index]</code>。所以我们不用自己进行强转。当存取一个泛型域时也会自动插入强制类型转换。</p>
<h4 id="3-泛型类型变量不能是基本数据类型"><a href="#3-泛型类型变量不能是基本数据类型" class="headerlink" title="3. 泛型类型变量不能是基本数据类型"></a>3. 泛型类型变量不能是基本数据类型</h4><p>不能用类型参数替换基本类型。就比如，没有<code>ArrayList&lt;double&gt;</code>，只有<code>ArrayList&lt;Double&gt;</code>。因为当类型擦除后，<code>ArrayList</code>的原始类型变为<code>Object</code>，但是<code>Object</code>类型不能存储<code>double</code>值，只能引用<code>Double</code>的值。</p>
<h4 id="4-编译时集合的instanceof"><a href="#4-编译时集合的instanceof" class="headerlink" title="4. 编译时集合的instanceof"></a>4. 编译时集合的instanceof</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure></div>

<p>因为类型擦除之后，<code>ArrayList&lt;String&gt;</code>只剩下原始类型，泛型信息<code>String</code>不存在了。</p>
<p>那么，编译时进行类型查询的时候使用下面的方法是错误的</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( arrayList <span class="keyword">instanceof</span> ArrayList&lt;String&gt;)</span><br></pre></td></tr></table></figure></div>

<h4 id="5-泛型在静态方法和静态类中的问题"><a href="#5-泛型在静态方法和静态类中的问题" class="headerlink" title="5. 泛型在静态方法和静态类中的问题"></a>5. 泛型在静态方法和静态类中的问题</h4><p>泛型类中的静态方法和静态变量不可以使用泛型类所声明的泛型类型参数</p>
<p>举例说明：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span>&lt;T&gt; &#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T one;   <span class="comment">//编译错误    </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  T <span class="title function_">show</span><span class="params">(T one)</span>&#123; <span class="comment">//编译错误    </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因为泛型类中的泛型参数的实例化是在定义对象的时候指定的，而静态变量和静态方法不需要使用对象来调用。对象都没有创建，如何确定这个泛型参数是何种类型，所以当然是错误的。</p>
<p><a class="link"   href="https://www.cnblogs.com/wuqinglong/p/9456193.html" >https://www.cnblogs.com/wuqinglong/p/9456193.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
</search>
